{"code":"import { Dom } from '../../core/dom';\r\nimport { Vector } from '../../core/vector';\r\nimport { JoinView } from '../common-views/join-view';\r\nimport { LabelView } from '../common-views/label-view';\r\nimport { RegionView } from '../common-views//region-view';\r\nimport { InputView } from '../common-views/input-view';\r\nexport const createSwitchStepComponentViewFactory = (cfg) => (parent, stepContext, viewContext) => {\r\n    const { step } = stepContext;\r\n    const g = Dom.svg('g', {\r\n        class: `sqd-step-switch sqd-type-${step.type}`\r\n    });\r\n    parent.appendChild(g);\r\n    const branchNames = Object.keys(step.branches);\r\n    const branchComponents = branchNames.map(branchName => {\r\n        return viewContext.createSequenceComponent(g, step.branches[branchName]);\r\n    });\r\n    const branchLabelViews = branchNames.map(branchName => {\r\n        const labelY = cfg.paddingTop + cfg.nameLabel.height + cfg.connectionHeight;\r\n        return LabelView.create(g, labelY, cfg.branchNameLabel, branchName, 'secondary');\r\n    });\r\n    const nameLabelView = LabelView.create(g, cfg.paddingTop, cfg.nameLabel, step.name, 'primary');\r\n    let prevOffsetX = 0;\r\n    const branchSizes = branchComponents.map((component, i) => {\r\n        const halfOfWidestBranchElement = Math.max(branchLabelViews[i].width, cfg.minContainerWidth) / 2;\r\n        const branchOffsetLeft = Math.max(halfOfWidestBranchElement - component.view.joinX, 0) + cfg.paddingX;\r\n        const branchOffsetRight = Math.max(halfOfWidestBranchElement - (component.view.width - component.view.joinX), 0) + cfg.paddingX;\r\n        const width = component.view.width + branchOffsetLeft + branchOffsetRight;\r\n        const joinX = component.view.joinX + branchOffsetLeft;\r\n        const offsetX = prevOffsetX;\r\n        prevOffsetX += width;\r\n        return { width, branchOffsetLeft, offsetX, joinX };\r\n    });\r\n    const centerBranchIndex = Math.floor(branchNames.length / 2);\r\n    const centerBranchSize = branchSizes[centerBranchIndex];\r\n    let joinX = centerBranchSize.offsetX;\r\n    if (branchNames.length % 2 !== 0) {\r\n        joinX += centerBranchSize.joinX;\r\n    }\r\n    const totalBranchesWidth = branchSizes.reduce((result, s) => result + s.width, 0);\r\n    const maxBranchesHeight = Math.max(...branchComponents.map(s => s.view.height));\r\n    const halfOfWidestSwitchElement = nameLabelView.width / 2 + cfg.paddingX;\r\n    const switchOffsetLeft = Math.max(halfOfWidestSwitchElement - joinX, 0);\r\n    const switchOffsetRight = Math.max(halfOfWidestSwitchElement - (totalBranchesWidth - joinX), 0);\r\n    const viewWidth = switchOffsetLeft + totalBranchesWidth + switchOffsetRight;\r\n    const viewHeight = maxBranchesHeight + cfg.paddingTop + cfg.nameLabel.height + cfg.branchNameLabel.height + cfg.connectionHeight * 2;\r\n    const shiftedJoinX = switchOffsetLeft + joinX;\r\n    Dom.translate(nameLabelView.g, shiftedJoinX, 0);\r\n    const branchOffsetTop = cfg.paddingTop + cfg.nameLabel.height + cfg.branchNameLabel.height + cfg.connectionHeight;\r\n    branchComponents.forEach((component, i) => {\r\n        const branchSize = branchSizes[i];\r\n        const branchOffsetLeft = switchOffsetLeft + branchSize.offsetX + branchSize.branchOffsetLeft;\r\n        Dom.translate(branchLabelViews[i].g, switchOffsetLeft + branchSize.offsetX + branchSize.joinX, 0);\r\n        Dom.translate(component.view.g, branchOffsetLeft, branchOffsetTop);\r\n        if (component.hasOutput && stepContext.isOutputConnected) {\r\n            const endOffsetTopOfComponent = cfg.paddingTop + cfg.nameLabel.height + cfg.branchNameLabel.height + cfg.connectionHeight + component.view.height;\r\n            const missingHeight = viewHeight - endOffsetTopOfComponent - cfg.connectionHeight;\r\n            if (missingHeight > 0) {\r\n                JoinView.createStraightJoin(g, new Vector(switchOffsetLeft + branchSize.offsetX + branchSize.joinX, endOffsetTopOfComponent), missingHeight);\r\n            }\r\n        }\r\n    });\r\n    let inputView = null;\r\n    if (cfg.inputSize > 0) {\r\n        const iconUrl = viewContext.getStepIconUrl();\r\n        inputView = InputView.createRectInput(g, shiftedJoinX, 0, cfg.inputSize, cfg.inputIconSize, iconUrl);\r\n    }\r\n    JoinView.createStraightJoin(g, new Vector(shiftedJoinX, 0), cfg.paddingTop);\r\n    JoinView.createJoins(g, new Vector(shiftedJoinX, cfg.paddingTop + cfg.nameLabel.height), branchSizes.map(o => new Vector(switchOffsetLeft + o.offsetX + o.joinX, cfg.paddingTop + cfg.nameLabel.height + cfg.connectionHeight)));\r\n    if (stepContext.isOutputConnected) {\r\n        const ongoingSequenceIndexes = branchComponents\r\n            .map((component, index) => (component.hasOutput ? index : null))\r\n            .filter(index => index !== null);\r\n        const ongoingJoinTargets = ongoingSequenceIndexes.map((i) => new Vector(switchOffsetLeft + branchSizes[i].offsetX + branchSizes[i].joinX, cfg.paddingTop + cfg.connectionHeight + cfg.nameLabel.height + cfg.branchNameLabel.height + maxBranchesHeight));\r\n        if (ongoingJoinTargets.length > 0) {\r\n            JoinView.createJoins(g, new Vector(shiftedJoinX, viewHeight), ongoingJoinTargets);\r\n        }\r\n    }\r\n    const regions = branchSizes.map(s => s.width);\r\n    regions[0] += switchOffsetLeft;\r\n    regions[regions.length - 1] += switchOffsetRight;\r\n    const regionView = RegionView.create(g, regions, viewHeight);\r\n    return {\r\n        g,\r\n        width: viewWidth,\r\n        height: viewHeight,\r\n        joinX: shiftedJoinX,\r\n        placeholders: null,\r\n        sequenceComponents: branchComponents,\r\n        getClientPosition() {\r\n            return regionView.getClientPosition();\r\n        },\r\n        resolveClick(click) {\r\n            return regionView.resolveClick(click) || g.contains(click.element) ? true : null;\r\n        },\r\n        setIsDragging(isDragging) {\r\n            inputView === null || inputView === void 0 ? void 0 : inputView.setIsHidden(isDragging);\r\n        },\r\n        setIsSelected(isSelected) {\r\n            regionView.setIsSelected(isSelected);\r\n        },\r\n        setIsDisabled(isDisabled) {\r\n            Dom.toggleClass(g, isDisabled, 'sqd-disabled');\r\n        },\r\n        hasOutput() {\r\n            return branchComponents.some(c => c.hasOutput);\r\n        }\r\n    };\r\n};\r\n","references":["C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/core/dom.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/core/vector.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/definition.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/workspace/common-views/join-view.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/workspace/common-views/label-view.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/workspace/common-views/region-view.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/workspace/common-views/input-view.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/workspace/component.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/designer-extension.ts","C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/src/workspace/switch-step/switch-step-component-view-configuration.ts"],"dts":{"name":"C:/Users/abrah/Documents/sequential/sequential-workflow-designer/designer/build/workspace/switch-step/switch-step-component-view.d.ts","writeByteOrderMark":false,"text":"import { StepComponentViewFactory } from '../../designer-extension';\r\nimport { SwitchStepComponentViewConfiguration } from './switch-step-component-view-configuration';\r\nexport declare const createSwitchStepComponentViewFactory: (cfg: SwitchStepComponentViewConfiguration) => StepComponentViewFactory;\r\n"}}
